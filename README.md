# avito-pr-reviewer-service

## Что добавлено:
- Ручки: листинг всех пользователей / команд с участниками в ней. Это было сделано для того, чтобы было удобнее смотреть на команды, участников и ПРы в процессе отладки программы
- JWT-токены и админ-доступ. Сделано, тк я смотрела версию openapi до того, как оттуда убрали авторизацию
- Батч-запросы для деактивации пользователей и команд
- Ручка статистики `/statistics`, которая показывает информацию о ПРах, пользователях, командах и назначениях ревьюеров
- Настроен линтер
- Присутствуют [бенчмарк](benchmark_results.txt) и e2e тесты 
- Имеется сваггер документация

## Особенности
Админский доступ определяется с помощью команды `admins`, в которой будут только админы и никто больше

В миграциях есть [файл](/migrations/006_create_admin_system.sql), который создает главного админа. Для работы с приложением необходимо залогиниться сначала через него

## Запуск

### Docker
```bash
docker-compose up --build -d
```

Сервис будет доступен на `http://localhost:8080`, а сваггер - `http://localhost:8080/swagger`

### Локальный запуск

1. Установите зависимости:
```bash
make deps
```

2. Запустите PostgreSQL с миграциями
```bash
docker compose up -d postgres goose 
```

3. Запустите сервис:
```bash
make run
```

## API Endpoints

### Health
- `HEAD /health` - ручка проверки здоровья приложения

### Auth
- `POST /auth/login` - получить jwt-токен

### Teams
- `POST /team/add` - Создать команду
- `GET /team/get?team_name={name}` - Получить команду

### Users
- `GET /users/getReview?user_id={id}` - Получить PR пользователя

### Pull Requests
- `POST /pullRequest/create` - Создать PR
- `POST /pullRequest/merge` - Смержить PR
- `POST /pullRequest/reassign` - Переназначить ревьювера

### Admin's Rights
- `GET /admin/teams` - Листинг всех команд с участниками в них
- `GET /admin/users` - Листинг всех пользователей
- `POST /users/setIsActive` - Установить статус активности
- `POST /users/batchDeactivateTeam` - Массовая деактивация пользователей в команде
- `POST /users/batchDeactivateUsers` - Массовая деактивация перечисленных в запросе пользователей

## Переменные окружения
Можно посмотреть в [этом](.env.example) файле

## Неупомянутые Makefile команды
```bash
make update-docs              # Обновляет локальную доку 
make install-golangci-lint    # Загрузка пакета с линтером (если нет)
make lint                     # Запуск линтера
make install-tools            # Загрузка сваггера и гуся для миграций
make up                       # Запуск миграций
make down                     # Откат миграций
```

## Тестирование

Для запуска тестирования необходимо поднять базу для тестирования в докере (см компоуз в `/tests` и используй make-команды), сервис локально и использовать make-команды:
```bash
make test-db-setup            # подъем тестовой базы с миграциями
make test-db-teardown         # погашение тестовой базы с миграциями
make test-e2e                 # запуск e2e тестов
make benchmark                # запуск benchmark тестов
```

### Вывод по результатам бенчмарк-тестов

Бенчмарки оценивают производительность операций деактивации пользователей и перераспределения их PR в зависимости от размера входных данных. Тесты выполнялись на **Apple M2 Pro (darwin/arm64)**.

### 1. BatchDeactivateUsers
Производительность ожидаемо снижается по мере увеличения количества пользователей и PR. Основные метрики:

| Размер набора | Время, ns/op | Память, B/op | Аллокации, allocs/op | Комментарии |
|---------------|--------------|--------------|------------------------|-------------|
| Small (10→5, 20 PRs)   | ~28.8 млн | ~93 KB  | ~1.7K  | Быстро, низкая нагрузка |
| Medium (50→25, 100 PRs) | ~163 млн | ~2 MB   | ~18K   | Рост нагрузки ×6–7 по времени |
| Large (100→50, 500 PRs) | ~759 млн | ~17.9 MB | ~136K  | Существенное увеличение стоимости операций |

**Observation:**
Рост входных данных приводит к почти линейному увеличению времени, но память возрастает значительно быстрее — в 8× между Medium и Large.

### 2. Первые прогоны (логируемые)
Время выполнения внутри одного бенчмарка заметно варьируется:

- Small: 13–32 ms
- Medium: ~95 ms
- Large: 448–455 ms

Можно сказать, что есть стабильность на средних и больших наборах и разброс на маленьких

### 3. SingleUserDeactivation
| Тест | ns/op | B/op | allocs/op |
|------|-------|-------|------------|
| SingleUserDeactivation | ~775k | 308 | 8 |

Очень дешёвая операция — быстрая и почти не использует память. Отлично подходит для одиночных запросов


Получается, что алгоритм масштабируется линейно по времени, но плох по памяти при больших наборах данных (особенно 500 PR).



